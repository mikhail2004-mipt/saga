## Saga-паттерн

Этот репозиторий — учебный пример, который показывает работу паттерна **Saga** для распределённых транзакций (когда один заказ затрагивает несколько сервисов).

Здесь **нет базы данных** и **нет веба**. Мы запускаем один скрипт, который “делает заказ” и печатает **логи** работы Saga.

Храним в памяти только минимум:
- баланс пользователей
- остатки на складе
- остатки промокодов
- список строк‑логов (для демо и тестов)

---

## Зачем вообще нужна Saga

Представь, что мы делаем заказ в интернет‑магазине. Для одного заказа нужно:

- **Списать деньги** (Billing)
- **Зарезервировать товар** (Inventory)
- **Применить промокод** (Discounts)
- **Подтвердить заказ** (Order / Finalize)

Если бы это была одна база данных и один сервис — можно было бы сделать “настоящую транзакцию” (commit/rollback).

Но в микросервисах так обычно нельзя:

- разные сервисы живут отдельно
- разные хранилища/БД
- нет одного “общего rollback” на всех

### Основная идея Saga

**Saga = цепочка шагов.**

- Каждый шаг делает *маленькое изменение* (например, “списали деньги”).
- Если потом где-то произошла ошибка — мы **не откатываем всю систему транзакцией**,
  а выполняем **компенсационные действия** (compensation), то есть “анти‑шаги”:
  - “списали деньги” → “вернули деньги”
  - “зарезервировали товар” → “разрезервировали товар”
  - “заняли промокод” → “вернули промокод”

Это и есть “компенсационные транзакции”.

---

## Какой вариант Saga реализован здесь

Здесь реализован вариант **Saga Orchestrator (оркестратор)**:

- есть центральный класс **`SagaOrchestrator`**
- он знает порядок шагов и запускает их по очереди
- при ошибке он запускает компенсации в обратном порядке

Схема:

1) `ReservePromoUse` (если есть промокод)  
2) `ReserveInventory`  
3) `ChargeUserBalance`  
4) `FinalizeOrder`  

Если на шаге 3 произошла ошибка, то компенсации будут такие:

- `Compensate_ReserveInventory`
- `Compensate_ReservePromoUse`

---

## Как устроен код (самое важное)

### Структура проекта

- `saga_demo/` — пакет с “сервисами” и оркестратором Saga
- `run_order.py` — один скрипт, который запускает “заказ” и печатает логи
- `tests/` — тестовые сценарии (показывают успех/падения/компенсации)

### Где хранится “состояние системы”

Файл `saga_demo/store.py`:

- `Store` — минимальное хранилище:
  - `users`, `items`, `promos` — текущее состояние ресурсов
  - `logs` — список строк, куда пишутся все события

### Сервисы (как будто “микросервисы”)

Файл `saga_demo/services.py`:

- `BillingService` — списание/возврат денег
- `InventoryService` — резерв/разрезерв товара
- `DiscountsService` — резерв/возврат промокода (+ расчет скидки)

Важно: это не настоящий микросервис (без сети). Это **учебная имитация**: “каждый сервис = отдельный класс”.

### Шаги Saga

- `saga_demo/saga.py` содержит:
  - базовый класс шага `Step`
  - конкретные шаги: `ReservePromoUse`, `ReserveInventory`, `ChargeUserBalance`, `FinalizeOrder`

### Оркестратор Saga

Файл `saga_demo/saga.py`:

- `SagaOrchestrator.execute(request, fail_at_step=None)` — запускает цепочку шагов
- если шаг падает → запускаются компенсации в обратном порядке

Параметр `fail_at_step` нужен **только для демо** — он искусственно “роняет” Saga на нужном шаге, чтобы увидеть компенсации.

---

## Как запустить (для друга, который почти не знает Python)

Нужен Python **3.10+**.

### 0) Проверить Python

Открой терминал в папке проекта и выполни:

```bash
python3 --version
```

Должно быть \(минимум\) `3.10`.

### 1) Создать виртуальное окружение (рекомендуется)

```bash
python3 -m venv .venv
source .venv/bin/activate
```

Если ты в Windows PowerShell, то активация будет такой:

```bash
.venv\Scripts\Activate.ps1
```

### 2) Установить зависимости (только для тестов)

Для запуска `run_order.py` зависимости не нужны.  
Но чтобы запускать тесты, поставь `pytest`:

```bash
python3 -m pip install -U pip
python3 -m pip install -e ".[dev]"
```

### 3) Запустить “запрос на заказ” и посмотреть логи

```bash
python3 run_order.py
```

### 4) Самое полезное — увидеть компенсации

Чтобы увидеть компенсации, “урони” Saga на нужном шаге:

```bash
python3 run_order.py --fail-at FinalizeOrder
```

### 5) Полезные примеры команд (разные сценарии)

- **Успешно с промокодом**:

```bash
python3 run_order.py --promo DISCOUNT10
```

- **Промокод закончился → падение на первом шаге, компенсаций нет**:

```bash
python3 run_order.py --promo EXPIRED
```

- **Не хватает товара на складе → промокод компенсируется**:

```bash
python3 run_order.py --promo DISCOUNT10 --qty 999
```

- **Не хватает денег → склад + промокод компенсируются**:

```bash
python3 run_order.py --promo DISCOUNT10 --user-id 2 --sku ITEM002 --qty 2
```

---

## Как запустить тесты

```bash
pytest -q
```

Тесты специально сделаны как “обучающие сценарии”: они показывают, что меняется в состоянии и какие компенсации срабатывают.

---

## Какие сценарии покрывают тесты

Файл `tests/test_saga.py`:

- **успех без промокода**: товар уменьшается, баланс уменьшается, в логах `SAGA OK`
- **успех с промокодом**: промокод тратится, товар/баланс уменьшаются, в логах `SAGA OK`
- **ошибка из-за промокода**: Saga падает на первом шаге, ничего не успевает “занять”
- **ошибка из-за склада**: промокод успели “занять”, но товар не смогли — промокод возвращается компенсацией
- **ошибка из-за денег**: промокод и товар успели “занять”, но денег нет — и промокод, и товар возвращаются компенсациями
- **искусственная ошибка на финализации**: демонстрация “позднего падения” и полного отката занятых ресурсов

---

## Что объяснять при рассказе (готовый план на 7–10 минут)

### 1) Проблема “распределённой транзакции”

- Один “заказ” трогает несколько подсистем: скидки, склад, оплату.
- В микросервисах нет общего `rollback` на все сервисы.

### 2) Решение: Saga

- **Saga — это цепочка шагов**.
- Каждый шаг делает маленькое изменение.
- При ошибке выполняются **компенсации** (анти‑шаги) в обратном порядке.

### 3) Почему здесь оркестратор

- Есть один “дирижёр” `SagaOrchestrator`.
- Он знает порядок шагов и запускает их.
- Это проще объяснять и отлаживать, чем хореографию (события/шины/подписки).

### 4) На что смотреть в логах (это главное)

Покажи другу, что по логам можно восстановить весь сценарий:

- старт: `SAGA START`
- суммы: `amounts: base=... discount=... final=...`
- шаги: `STEP <name>` → `STEP <name> OK`
- ошибка: `SAGA FAILED: ...`
- компенсации: `COMPENSATE <name>` → `COMPENSATE <name> OK`
- итог: `SAGA OK` или `SAGA END (failed)`

### 5) Демо №1 (успешный)

Команда:

```bash
python3 run_order.py --promo DISCOUNT10
```

Что сказать:
- промокод уменьшается
- склад уменьшается
- баланс уменьшается
- в логах есть `SAGA OK`

### 6) Демо №2 (позднее падение и полный откат)

Команда:

```bash
python3 run_order.py --promo DISCOUNT10 --fail-at FinalizeOrder
```

Что сказать:
- первые шаги прошли успешно (ресурсы “заняты”)
- потом ошибка (искусственная)
- компенсации идут **в обратном порядке**
- итоговое состояние вернулось к исходному (баланс/склад/промо)

### 7) Важная честность (чем учебное отличается от продакшена)

- Здесь нет сетевых вызовов и параллельных запросов — это упрощение.
- В реальности нужны: идемпотентность, ретраи, дедупликация, мониторинг, корреляция логов, обработка “упала компенсация”.

## Ограничения (это нормально для учебного проекта)

- **Всё в памяти**: перезапустил программу — состояние исчезло.
- **Нет конкурентности**: мы не решаем гонки/блокировки/параллельные заказы.
- **Нет идемпотентности и ретраев**: в реальных системах это обязательно.
- **Нет очередей/HTTP**: это упрощённая модель “как будто микросервисы”.

Но главное здесь — **понять принцип**:

- шаги меняют состояние по чуть‑чуть
- при сбое всё возвращается через компенсации
